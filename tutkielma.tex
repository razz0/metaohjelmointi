% --- Template for thesis / report with tktltiki2 class ---
% 
% last updated 2013/02/15 for tkltiki2 v1.02

\documentclass[finnish]{tktltiki2}

% --- General packages ---

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}
%\usepackage[table,xcdraw]{xcolor}    % loads also »colortbl«
\usepackage{listings}
\usepackage{minted}
\usepackage{amsfonts,amsmath,amssymb,amsthm,booktabs,enumitem,graphicx}
\usepackage{tocloft}
%\usepackage{relsize}
\usepackage[pdftex,hidelinks]{hyperref}
\usepackage[title]{appendix}
%\usepackage{tabularx}
%\usepackage[table]{xcolor}    % loads also »colortbl«
%\usepackage{float}

%\listfiles

\linespread{1.3}

\setlength{\intextsep}{18pt plus 2.0pt minus 2.0pt}

\lstset{%
  language=[LaTeX]TeX,
  basicstyle=\ttfamily,
  breaklines=true,
  columns=fullflexible,
}

%\setlength{\arrayrulewidth}{0.6pt}

% Automatically set the PDF metadata fields
\makeatletter
\AtBeginDocument{\hypersetup{pdftitle = {\@title}, pdfauthor = {\@author}}}
\makeatother

% --- Language-related settings ---
%
% these should be modified according to your language

% babelbib for non-english bibliography using bibtex
\usepackage[fixlanguage]{babelbib}
\selectbiblanguage{finnish}

% add bibliography to the table of contents
\usepackage[nottoc]{tocbibind}
% tocbibind renames the bibliography, use the following to change it back
\settocbibname{Lähteet}

\declarebtxcommands{finnish}{%
    \def\btxurldatecomment#1{ [#1]}%
}

\renewcommand\listingscaption{Listaus}
\renewcommand\listoflistingscaption{Listaukset}

% --- Theorem environment definitions ---
\newtheorem{lau}{Lause}
\newtheorem{lem}[lau]{Lemma}
\newtheorem{kor}[lau]{Korollaari}

\theoremstyle{definition}
\newtheorem{maar}[lau]{Määritelmä}
\newtheorem{ong}{Ongelma}
\newtheorem{alg}[lau]{Algoritmi}
\newtheorem{esim}[lau]{Esimerkki}

\theoremstyle{remark}
\newtheorem*{huom}{Huomautus}

% --- Custom hyphenations ---

% --- tktltiki2 options ---
%
% The following commands define the information used to generate title and
% abstract pages. The following entries should be always specified:

\title{Metaohjelmointi Python-kielellä}
\author{Mikko Koho}
\date{\today}
\level{Seminaarityö}

\abstract{Tiivistelmä.
}

\keywords{Python, metaohjelmointi}
\classification{
}
% classification according to ACM Computing Classification System (http://www.acm.org/about/class/)
                  % This is probably mostly relevant for computer scientists

% If the automatic page number counting is not working as desired in your case,
% uncomment the following to manually set the number of pages displayed in the abstract page:
%
%\numberofpagesinformation{59 sivua + 7 liitesivua}
%








%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% TODO: Vertaisarviointien yleisiä huomioita:

% Esimerkkien laatikointi tai sisennys.
% Lukuun 3 lisää esimerkkejä (oli 3) [x3].
% Lukuun 3 lisää tekstiä metaohjelmoinnin eri työkaluista, nyt lähinnä listattu. [x2]
% Hyvä kertoa minkälaisissa tapauksissa jostain metapiirteestä voi olla hyötyä [x2]
% Kirjalähteisiin viitatessa sivunumerot mukaan
% Dynaamisten luokkien esimerkki laajemmaksi
% kuinka Python-metaohjelmointia on oikeasti hyödynnetty
% Esimerkki AST:n tarkastelusta ja muokkauksesta [x3]
% Lisää tekstiä ja esimerkki template-metaohjelmoinnista [x2]
% Esimerkit lähemmäs tekstissä olevaa viitettä [x2]
% Esimerkki luokan muokkaamisesta ajoaikana ja selvennystä miten muokkaus vaikuttaa olioihin
% Selosta esimerkit tekstissä rivi riviltä

%%%%%%% TODO Muuta:

% Metaohjelmointi-in-action: http://blog.ducksboard.com/runtime-code-modification-erlang-python/
% Esimerkki missä maagisia metodeja muokkaamalla tehdään esim. numerosta luokka! (hyötyä?)
% Asioita ja esimerkkejä esityksestä tekstiin

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
    
% --- Front matter ---

\frontmatter      % roman page numbering for front matter

\maketitle        % title page

\makeabstract     % abstract page

\tableofcontents  % table of contents

% --- Main matter ---

\mainmatter       % clear page, start arabic page numbering


%%%%%%%%%%%%%%%%%%%
\section{Johdanto}
%%%%%%%%%%%%%%%%%%%

Metaohjelmoinnilla tarkoitetaan klassisen määritelmän mukaan sellaisen tietokoneohjelman tekemistä, joka kirjoittaa uusia tietokoneohjelmia \cite[s. 6]{hazzard2013}. Tämä on kuitenkin melko yksinkertaistettu määritelmä, eikä metaohjelmointia ole helppo määritellä tarkasti. Toinen yleinen määritelmä esittää metaohjelmoinnin olevan ''tietokoneohjelma, joka manipuloi toisia ohjelmia suoritusaikana'' \cite[s. 7]{hazzard2013}. 

Tärkeä osa metaohjelmointia on ohjelman suoritusaikainen tilansa tarkastelu ja muuntelu eli reflektio. Reflektioon kuuluu käsite introspektio, jolla tarkoitetaan suoritusaikaista muistissa olevien olioiden tarkastelua \cite{dive-into-python}.

Tässä seminaarityössä tarkastellaan Python-ohjelmointikielen tarjoamia työkaluja metaohjelmointiin. Alussa käydään läpi Python-kielen perusteita, ja tämän jälkeen tutustutaan metaohjelmointiin Python-kielellä. Metaohjelmoinnista tarkastellaan lähinnä suoritusaikaista metaohjelmointia. 



%%%%%%%%%%%%%%%%%%%
\section{Python-ohjelmointikieli}
%%%%%%%%%%%%%%%%%%%

Ensimmäinen Python-kielen versio on julkaistu 1991. Pythonin suosio on kasvanut tasaisesti, ja se on nykyään käytetyin kieli ohjelmoinnin perusteiden opetukseen Yhdysvaltojen yliopistoissa \cite{python-teaching}. Python-kielestä on nykyään käytössä eri versioita. Python 2.7 on edelleen melko suosittu, vaikka versio 3 on julkaistu jo 2008. Versio 3 ei ole yhteensopiva aiempien versioiden kanssa. Python 3:n yleistymistä on hidastanut se, että jotkut suositut kirjastot ja sovelluskehykset käyttävät edelleen Python 2:ta eivätkä ole siirtyneet versioon 3.

Python-ohjelmakoodia voidaan kääntää useilla eri kääntäjillä \cite{martelli2006python}. Käytetyin kääntäjä on CPython (Classic Python), joka kääntää alkuperäisen koodin Python-tavukoodiksi. Muita suosittuja kääntäjiä ovat Java-tavukoodiksi kääntävä Jython sekä IronPython, joka kääntää Python-koodia .NET-ympäristön käyttämäksi CIL-tavukoodiksi. PyPy on Python-kielellä toteutettu useissa eri ympäristöissä toimiva suoraan konekielelle koodia kääntävä suoritusaikainen (just-in-time) kääntäjä. %PyPy on toteutettu RPython-kielellä, joka on Python-kielen osajoukko.

CPythonilla käännettyä tavukoodia voidaan ajaa C-kielellä toteutetulla virtuaalikoneella \cite{martelli2006python}. Pythonin standardikirjasto on toteutettu osittain C:llä ja osittain Pythonilla.

Seminaarityön esimerkit toimivat sekä Python 2.7:llä että Python 3:lla. Esimerkeissä ohjelman tulosteet on kirjoitettu kommenttiriveinä tulosteen tuottavan rivin jälkeen.

Tässä luvussa käydään läpi Python-kielen perusteita ja metaohjelmoinnin kannalta olennaisia asioita.

\subsection{Syntaksi}

Python ohjelma koostuu loogisista riveistä, jotka ovat yhden tai useamman fyysisen rivin mittaisia. \cite{martelli2006python}. Loogisten rivien päättämiseen ei käytetä mitään merkkiä. Rivien sisennyksen perusteella erotetaan ohjelmakoodin lohkot toisistaan. Suositeltu tapa sisentää on käyttää ensimmäisen tason sisentämiseen 4 välilyöntiä ja seuraavaan 8 ja niin edelleen \cite{pep8}. 

Pythonissa on 30 avainsanaa (keyword), jotka ovat kielen varattuja sanoja. Näitä ovat esimerkiksi funktio \verb|print| ja kielen rakenteissa käytetyt sanat kuten \verb|if|, \verb|and| ja \verb|class|. Pythonin standardikirjasto koostuu sisäänrakennettujen funktioiden lisäksi kokoelmasta eri tarkoituksiin soveltuvia moduuleita (module), jotka pitää tarvittaessa tuoda erikseen osaksi suoritettavaa ohjelmaa komennolla \verb|import|.

\subsection{Muuttujat}

Python on dynaamisesti tyypitetty kieli. Muuttujien arvon tyyppiä ei tarvitse eksplisiittisesti määrittää, vaan tyyppi määräytyy sen perusteella minkälainen arvo muuttujaan sijoitetaan. Muuttujan arvoa voidaan vaihtaa sijoittamalla siihen uusi arvo. Uuden arvon ei tarvitse olla saman tyyppinen kuin muuttujan vanha arvo, vaan muutujan tyyppiä voidaan vaihtaa sijoittamalla siihen eri tyyppinen arvo. Listaus \ref{lst:ex1} sisältää yksinkertaisen esimerkin Python-kielen syntaksista. Rivillä 1 asetetaan muuttujan \verb|a| arvoksi merkkijono ''\verb|Hello world!|'', joka tulostetaan rivillä 2. Rivillä 5 tulostetaan muuttujassa \verb|a| olevan merkkijonon pituus.

%Modernit IDE:t kuten PyCharm\footnote{\url{https://www.jetbrains.com/pycharm/}} pystyvät koodin perusteella usein päättelemään muuttujan tyypin.

\begin{listing}
    \inputminted[linenos]{python}{code/foo.py}
    \caption{Yksinkertainen esimerkki Python-kielen syntaksista.}
    \label{lst:ex1}
\end{listing}

\subsection{Tietotyypit}

Pythonissa kaikki arvot, muuttujat ja funktiot ovat olioita. Olion tyyppi määrittää, mitä metodeja ja ominaisuuksia olio tarjoaa. Osa olioista on muuttumattomia (immutable) ja osa muutettavia (mutable). Python-kielessä ei ole erikseen vakioita, mutta käytäntönä on käyttää muuttujan nimessä pelkästään isoja kirjaimia, jos arvoa ei ole tarkoitus muuttaa.

Pythonin sisäänrakennettuja tietotyyppejä ovat muun muuassa numeeriset \verb|int| (kokonaisluku) ja \verb|float| (liukuluku), sekvenssityypit \verb|list| (lista), \verb|str| (merkkijono) ja \verb|tuple| (monikko), joukko \verb|set|, sanakirja \verb|dict| sekä tiedosto \verb|file|. Sanakirja-tyyppi tunnetaan joissain ohjelmointikielissä hajautustauluna. Hajautustaulu onkin ainakin CPythonin sisäinen toteutus sanakirjasta, mutta muitakin mahdollisia toteutustapoja on. Standardikirjastoon kuuluvista moduuleista löytyy lisää tietotyyppejä kuten aikatyyppi \verb|datetime| ja taulukko \verb|array|.

Sekvenssit ovat iteroitavia (iterable) olioita, eli ne kykenevät palauttamaan jäseniään yksi kerrallaan. Iteroitavia olioita ovat myös muut oliot, joissa on toteutettu jäseniä palauttava \verb|__iter__| tai \verb|__get_item__| -metodi. Iteroitavia olioita voidaan käyttää suoraan osana esimerkiksi \verb|for| -toistolauseissa. kuten esimerkiksi lauseessa 
\\\lstinline|for x in [1,2,3]: print(x)|

\subsection{Kehitelmät}

Listakehitelmä (list comprehension) on matemaatiikan joukkojen määrittelyn merkintätavan pohjalta luotu syntaksi listan määrittelyyn olemassa olevien listojen pohjalta. Pythoniin on kehitetty myös listakehitelmän syntaksiin perustuvat joukkokehitelmä (set comprehension) ja sanakirjakehitelmä (dictionary comprehension). Nämä kaikki kehitelmät ovat helppoja tapoja luoda lista-, joukko- tai sanakirjaolioita.

Esimerkkejä listakehitelmän käytöstä sekä joidenkin Python-kielen funktioiden käytöstä on listauksessa \ref{lst:ex_listakehis}. Funktio \verb|range| palauttaa Python 2:ssa listan ja Python 3:ssa generaattoriolion, jota voidaan käyttää listan tapaan. Funktio \verb|all| tarkastaa kaikkien listan (tai muun iteroitavan olion) totuusarvon. Pythonissa kaikki sisäänrakennettujen tietotyyppien oliot voidaan evaluoida totuusarvoina, jolloin lukujen tapauksessa aina luku ''0'' evaluoituu epätodeksi ja muut luvut todeksi.

% TODO: Selosta esimerkki
\begin{listing}
    \inputminted[linenos]{python}{code/luvut.py}
    \caption{Esimerkki listakehitelmistä ja funktion range käytöstä.}
    \label{lst:ex_listakehis}
\end{listing}


\subsection{Luokat ja oliot}

Python on olio-ohjelmointikieli, joka ei kuitenkaan pakota käyttämään olio-ohjelmointia ohjelmien toteutuksessa. 

Pythonissa myös luokat ovat olioita. Luokilla on joitain piirteitä kuten muodostin (constructor) metodissa \verb|__init__|, jotka mahdollistavat niiden käyttämisen luokkina. Luokka voi periä yhden tai useamman luokan. Luokka määritellään lausekkeella \lstinline|class ClassName(InheritedClass, AnotherInherited)|. Python 2:ssa luokan tulisi periä ainakin \verb|object|, jolloin se muodostaa niin sanotun uudentyyppisen luokan \cite{martelli2006python}. Python 2.2:ssa luokkien rakenne muuttui ja uusi rakenne toteutettiin \verb|object|-luokkaan, jota käytetään Python 3:ssa oletuksena. Uudentyyppisten luokkien \emph{metaluokka} on aina \verb|type| \cite{martelli2006python}. Metaluokkaa käytetään muodostimena luotaessa uusi luokkaolio \cite{MetaprogP3}. Metaluokkia voi määritellä itse, mutta tälle on harvoin tarvetta.
%Python-kielen yhteydessä käytetään usein tyyppiä (type) luokan synonyyminä.

Kahdella alaviivalla metodin nimen alussa ja lopussa merkitään luokan ''maagisia'' metodeita (magic methods) ja attribuutteja \cite{martelli2006python}, joilla on jokin erityinen käyttötarkoitus Pythonissa. Nämä metodit ja niiden toimintaa ja käyttöä on selitetty Pythonin dokumentaatiossa \cite{magic-methods}. Osa ''maagisista'' metodeista on sellaisia, että Python generoi ne olion luomisen yhteydessä, jolloin ne sisältävät jotain metatietoa itse oliosta. Monet ''maagisista'' metodeista ovat sellaisia, että niitä määrittelemällä tai muokkaamalla jo määriteltyjä voidaan vaikuttaa olion toimintaan ohjelmassa \cite{magic-methods}. Esimerkiksi muokkaamalla luokan \verb|__cmp__(self, other)|-metodia, voidaan ylikirjoittaa kahden luokasta muodostetun olion suuruusvertailu omalla metodilla. Samoin aritmeettisille operaattoreille on kullekin omat ''maagiset'' metodit. 

Metaluokan metodeilla \verb|__instancecheck__(self, instance)| ja \\\lstinline|__subclasscheck__(self, subclass)| voidaan vaikuttaa siihen miten ajoaikainen reflektio käyttäytyy \cite{magic-methods, Python-docs}. Näistä ensimmäistä käytetään yliajamaan (override) Pythonin sisäänrakennetun funktion \verb|isinstance| toimintaa, joka kertoo onko instanssi muodostettu tietystä luokasta. Jälkimmäinen yliajaa sisäänrakennetun funktion \verb|issubclass| toimintaa ja kertoo onko luokka toisen luokan aliluokka. Reflektion toiminnan muokkaamiselle on vaikea keksiä hyötykäyttöä, mutta se on mielenkiintoinen esimerkki Pythonin dynaamisuudesta.

% TODO: Moniperintä-esimerkki kalvoista ja Pythonin moniperinnän kuvaus

% TODO: Selitä auki metaluokat

%%%%%%%%%%%%%%%%%%%
\section{Metaohjelmointi Pythonilla}
%%%%%%%%%%%%%%%%%%%

% TODO: Parempi otsikko

Metaohjelmointi on Pythonilla hyvin luontevaa, koska olioita voidaan tutkailla ja yleensä muokata suoritusaikana vapaasti, ja niistä saadaan paljon metatietoa Pythonin peruskirjaston työkaluilla.

% TODO: assert

\subsection{Reflektio}


% TODO: Esimerkki luokan metodin ylikirjoittamisesta

Olion luokka saadaan kutsumalla \verb|type|:ä niin, että parametrina on olio, jonka luokka halutaan selvittää \cite{dive-into-python}. 

Funktio \verb|dir| palauttaa listan olion attribuuteista, joihin kuuluu myös olion metodit. Funktio \verb|getattr| ottaa parametrina merkkijonon ja palauttaa parametrin nimisen attribuutin. Tällöin voidaan esimerkiksi kutsua metodeja oliosta, jonka rakennetta ei tunnetta vielä käännösvaiheessa \cite{dive-into-python}. Funktiolla \verb|isinstance| voidaan tarkistaa, onko joku olio tietyn tyyppinen. 

Olion lyhyen sanallisen kuvauksen saa suoritusaikana haettua sen \verb|__doc__| -attribuutista. Kuvaus on koodissa oliolle annettu \emph{docstring}-kuvailu, joka on Pythonissa tyypillinen tapa kuvailla tekstinä ohjelman komponentteja.

Olioita, luokkia ja funktioita voidaan muokata suoritusaikana melko vapaasti. Esimerkki peruskirjaston \verb|dir| funktion korvaamisesta omalla funktiolla on listauksessa \ref{lst:ex_intro2}. Esimerkin oma funktio palauttaa sille annetut argumentit tekemättä niille mitään. Tämänkaltaisesta kirjastojen ja moduuleiden osien suoritusaikaisesta muokkaamisesta käytetään nimeä ''monkey patching''.

% käytä .getattr('print') ?
\begin{listing}
    \inputminted[linenos]{python}{code/introspektio2.py}
    \caption{Standardikirjaston funktion korvaaminen omalla funktiolla.}
    \label{lst:ex_intro2}
\end{listing}

Pythonin standardikirjaston inspect-moduuli tarjoaa työkaluja olioiden tilan tutkimiseen ohjelman suoritusaikana. Moduuli sys tarjoaa työkaluja käytetyn Python-tulkin ja käyttöjärjestelmän tarkasteluun.

\subsection{Dynaamiset luokat}

Luokkia voidaan muokata ohjelman suoritusaikana, jolloin vaikutus ulottuu kaikkiin jo luotuihin luokan instansseihin. On myös mahdollista luoda uusia luokkia dynaamisesti ohjelman suoritusaikana \verb|type|-metaluokan avulla \cite{MetaprogP3}. Kutsumalla \verb|type|:ä kolmella parametrilla saadaan paluuarvona luokka. Parametrit ovat järjestyksessä luokan nimi, perittävät luokat ja sanakirja-tyyppinen muuttuja luokan sisällöstä \cite{MetaprogP3}. Esimerkiksi tyhjä luokka voidaan luoda dynaamisesti lausekkeella \verb|C = type('C', (), {})|.


% TODO: Kuorruttajat(?) (decorator) \cite{dubois2005nest}.

\subsection{Koodin kääntäminen suoritusaikana}

Pythonissa on sisäänrakennetut funktiot \verb|compile|, \verb|eval| ja \verb|exec|, joiden avulla voidaan kääntää ja ajaa Python-koodia ohjelman suoritusaikana \cite{codeobjects,martelli2006python}.

Esimerkki suoritusaikaisesta koodin kääntämisestä on listauksessa \ref{lst:ex_compile}. Esimerkin rivillä 1 luodaan muuttuja, joka sisältää käännettävän koodin merkkijonona. Rivillä 2 käännetään koodi merkkijonosta tavukoodiksi käyttämällä funktiota \verb|compile|, jonka parametrit ovat käännettävä koodi, koodin sisältävän tiedoston nimi ja käännöstila (mode). Nimenä käytetään merkkijonoa \verb|'<string>'| tarkoittamaan, että koodia ei ole luettu tiedostosta. Käännöstila \verb|'single'| kertoo, että käännetään yksi lause (statement). Rivi 4 tulostaa \verb|code_obj| -muuttujan merkkijonoesityksen. Rivillä 7 suoritetaan tavukoodi muuttujasta \verb|code_obj|.

\begin{listing}
    \inputminted[linenos]{python}{code/dynamichello.py}
    \caption{Esimerkki Python-lauseen kääntämisestä tavukoodiksi ohjelman suoritusaikana ja käännetyn koodin ajamisesta \cite{codeobjects}.}
    \label{lst:ex_compile}
\end{listing}


\subsection{Tavukoodin tarkastelu ja muokkaus}

Standardikirjaston \verb|dis|-moduulilla voidaan tutkia Python-tavukoodia. Listauksessa \ref{lst:tavukoodi} on esimerkki tavukoodin tulostamisesta \verb|dis|-moduulin \verb|dis|-metodilla sekä tulostettu tavukoodi. Tavukoodi on tulostettu Python 2:lla ja se on eri näköinen suoritettaessa esimerkki Python 3:lla.

% TODO: selitä esimerkki paremmin auki (vertaisarvio)

\begin{listing}
    \inputminted[linenos]{python}{code/tavukoodi.py}
    \caption{Python-tavukoodin tarkastelu dis-moduulilla.}
    \label{lst:tavukoodi}
\end{listing}

Moduuli \verb|parser| antaa rajapinnan Python-kääntäjän sisäiseen jäsennyspuuhun ja mahdollistaa sen muokkaamisen. Tämän moduulin lisäämisen jälkeen on kuitenkin standardikirjastoon lisätty \verb|ast|-moduuli, joka mahdollistaa kääntäjän abstraktin syntaksipuun (abstract syntax tree) luomisen annetun ohjelmakoodin perusteella ja sen muokkaamisen. Funktiolle \verb|compile| voidaan antaa parametrina muokatun AST-puun sisältävä \verb|AST|-luokan olio ja kääntää se tavukoodiksi.

% TODO Kalvojen AST-asiaa omaan alilukuun

% TODO AST-esimerkkiä: http://www.blueprintforge.com/blog/2012/02/27/static-modification-of-python-with-python-the-ast-module/

% TODO koodi -> AST-puu -> muokkaus -> koodi : http://code.activestate.com/recipes/578353-code-to-source-and-back/


\subsection{Käännösaikainen metaohjelmointi}

Käännösaikaista metaohjelmointia ei ole suoraan tuettu Pythonissa. Mallien (template) käyttö käännösaikana on mahdollista esimerkiksi Jinja2:lla \cite{jinja}.

Käännösaikainen metaohjelmointi on myös lisätty kahteen Pythonista jatkokehitettyyn kieleen, Mythoniin \cite{mython} ja Convergeen \cite{tratt05}. Mython-kieltä voidaan kääntää Python-tavukoodiksi, mutta Converge-kielestä käännettyä koodia suoritetaan kielen omalla virtuaalikoneella.

% TODO: Luvun loppuun yhteenvetokappale kokoamaan asiaa

%%%%%%%%%%%%%%%%%%%%%
\section{Yhteenveto}
%%%%%%%%%%%%%%%%%%%%%

%Yhteenveto.


\pagebreak

% --- References ---
%
% bibtex is used to generate the bibliography. The babplain style
% will generate numeric references (e.g. [1]) appropriate for theoretical
% computer science. If you need alphanumeric references (e.g [Tur90]), use
%
% \bibliographystyle{babalpha-lf}
%
% instead.

\bibliographystyle{babalpha-lf}
\bibliography{references-fi}

\lastpage

\end{document}
